# -*- coding: utf-8 -*-
"""opticalFlow_VectorVisualization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w2XwkKXePcIKXJwbb8NNOGR1HZLVmWkM
"""

#optical flow field overlaid on frame
import cv2 as cv
import numpy as np
import pandas as pd
from skimage.transform import rescale, resize, downscale_local_mean
import matplotlib.pyplot as plt
import matplotlib.cm as cm
width =100
height =100

# The video feed is read in as a VideoCapture object

cap = cv.VideoCapture('/content/drive/My Drive/MAE 496/Data/face2face vids/o/802.mp4')
cap2 = cv.VideoCapture('/content/drive/My Drive/MAE 496/Data/face2face vids/s/802_885.mp4')
# ret = a boolean return value from getting the frame, first_frame = the first frame in the entire video sequence
ret, first_frame = cap.read()
ret2, first_frame2 = cap2.read()
# Converts frame to grayscale because we only need the luminance channel for detecting edges - less computationally expensive
prev_gray = cv.cvtColor(first_frame, cv.COLOR_BGR2GRAY)
prev_gray2 = cv.cvtColor(first_frame2, cv.COLOR_BGR2GRAY)

while(cap.isOpened()):
    
    # ret = a boolean return value from getting the frame, frame = the current frame being projected in the video
    ret, frame = cap.read()
    #im1 = plt.imread(resize(frame,(64,64)))
    ret2, frame2 = cap2.read()
    #im2 = plt.imread(resize(frame2,(64,64)))
    # Opens a new window and displays the input frame
    #cv.imshow("input", frame)
    # Converts each frame to grayscale - we previously only converted the first frame to grayscale
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    gray2 = cv.cvtColor(frame2, cv.COLOR_BGR2GRAY)
    # Calculates dense optical flow by Farneback method
    # https://docs.opencv.org/3.0-beta/modules/video/doc/motion_analysis_and_object_tracking.html#calcopticalflowfarneback
    flow = cv.calcOpticalFlowFarneback(prev_gray, gray, None, 0.5, 3, 15, 3, 7, 1.5, 0)
    flow = resize(flow,(width,height))
    flow2 = cv.calcOpticalFlowFarneback(prev_gray2, gray2, None, 0.5, 3, 15, 3, 7, 1.5, 0)
    flow2 = resize(flow2,(width,height))
    # Computes the magnitude and angle of the 2D vectors
    #magnitude, angle = cv.cartToPolar(flow[..., 0], flow[..., 1])
    #magnitude2, angle2 = cv.cartToPolar(flow2[..., 0], flow2[..., 1])
    u = flow[..., 0]
    v = flow[..., 1]
    u2 = flow2[..., 0]
    v2 = flow2[..., 1]
    
    plt.figure(figsize=(20,10))
    plt.subplot(121)
    plt.imshow(resize(frame,(width,height)))
    plt.quiver(u,v,color = 'red')
    plt.subplot(122)
    plt.imshow(resize(frame2,(width,height)))
    plt.quiver(u2,v2,color = 'red')
    plt.show()

    prev_gray = gray
    prev_gray2 = gray2
    
    if cv.waitKey(10) & 0xFF == ord('q'):
        break

# The following frees up resources and closes all windows
cap.release()
cv.destroyAllWindows()

# visualizing the optical flow as a vector field over the image
import cv2 as cv
import numpy as np
import pandas as pd
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt

face_cascade = cv.CascadeClassifier('/content/drive/My Drive/MAE 496/Data/face detection/haarcascade_frontalface_default.xml')

# The video feed is read in as a VideoCapture object

cap = cv.VideoCapture('/content/drive/My Drive/MAE 496/Data/face2face vids/o/802.mp4')
cap2 = cv.VideoCapture('/content/drive/My Drive/MAE 496/Data/face2face vids/o/802.mp4')

ret, first_frame = cap.read()
ret2, first_frame2 = cap2.read()

prev_gray = cv.cvtColor(first_frame, cv.COLOR_BGR2GRAY)
prev_gray2 = cv.cvtColor(first_frame2, cv.COLOR_BGR2GRAY)


while(cap.isOpened()):
    
    # ret = a boolean return value from getting the frame, frame = the current frame being projected in the video
    ret, frame = cap.read()
    ret2, frame2 = cap2.read()
    
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    gray2 = cv.cvtColor(frame2, cv.COLOR_BGR2GRAY)
    
    face = face_cascade.detectMultiScale(gray, 1.1, 4)
    for (x, y, w, h) in face:
      startX = int(x)
      endX = int(x + w)
      startY = int(y)
      endY = int((y + h)*1.05)
   
    face2 = face_cascade.detectMultiScale(gray2, 1.1, 4)
    for (x, y, w, h) in face2:
      startX2 = int(x)
      endX2 = int(x + w)
      startY2 = int(y)
      endY2 = int((y + h)*1.05)

    face_pic = frame[startY:endY,startX:endX]
    face_pic = cv.resize(face_pic,(100,100))

    face_pic2 = frame2[startY2:endY2,startX2:endX2]
    face_pic2 = cv.resize(face_pic2,(100,100))



    flow = cv.calcOpticalFlowFarneback(prev_gray, gray, None, 0.5, 3, 15, 3, 7, 1.5, 0)
    flow_face = flow[startY:endY,startX:endX]  
    flow_face = cv.resize(flow_face,(100,100))

    flow2 = cv.calcOpticalFlowFarneback(prev_gray2, gray2, None, 0.5, 3, 15, 7, 5, 1.5, 0)
    flow_face2 = flow2[startY2:endY2,startX2:endX2]  
    flow_face2 = cv.resize(flow_face2,(100,100))


    u = flow_face[..., 0]
    v = flow_face[..., 1]
    u2 = flow_face2[..., 0]
    v2 = flow_face2[..., 1]

    plt.figure(figsize=(20,10))
    plt.subplot(121)
    plt.imshow(face_pic)
    plt.quiver(u,v,color = 'red' )
    plt.subplot(122)
    plt.imshow(face_pic2)
    plt.quiver(u2,v2,color = 'red' )
    plt.show()
    

    # Updates previous frame
    prev_gray = gray

pip install --user tensorflow_addons==0.6.0